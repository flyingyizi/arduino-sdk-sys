# arduino-sys

Rust bindings for `arduino`.

it is a somewhat idiomatic Rust wrapper for arduino core/external libraries bindings, target is use arduino c/c++ library in rust project.

Released under the Apache License 2.0.

## features

the `prettify_bindgen` Cargo feature is disable defautly, it need [clang-rs](https://github.com/KyleMayes/clang-rs). if this feature enable, the binding output will be more simple, because it will limit the output only in the scope of external libraries headers, not others contents that belongs to "#include ...".

## Dependencies

this crate need arduino-cli in the `PATH` env. need arduino-cli to get the arduino data/user directory, and get the installed plaform version related the to target fqbn(VENDOR:ARCHITECTURE:BOARD_ID).


this crate will wrapper libarduino_core.a and libarduino_external.a to be a rlib used by the down-stream app. those libraries is generated by this crate. how to compile them depends on the  arduino configurations(platform.txt, boards.txt, and package_index.json) and the down-stream configuration. the down-stream configuration detials will be descripted on blow.

the libarduino_core.a will stored in this crate `CARGO_MANIFEST_DIR/arudino-lib/<arduino fqbn info>/boardid`, to decreae compile time in the future.

the libarduino_external.a is stored in down-stream app `OUT_DIR`. it means, when the down-stream app re-build, it will generated again. the reason is its compile time is acceptable.

this crate only generate bindings for the external libraris listed in "external_libraries" of the down-stream configuration. the external libraries source must be located in arduino user directory (sketchbook).

## Environment Variables

when down-steam app use this crate, firstly, the down-steam app need to add this crate in its dependencies. then  "ARDUINO_SYS" var definition need to be defined 
in  [Cargoâ€™s configuration file](https://doc.rust-lang.org/cargo/reference/config.html) of down-stream App. 

```toml
[env]
# Value is relative to .cargo directory containing `config.toml`, make absolute
ARDUINO_SYS = { value = "custom.json", relative = true }
```

custom config file(e.g. file name is "custom.json") sample:

```json
{
    "fqbn": "arduino:avr:uno",
    "compile_flags": {
        "c": ["-Da"],
        "cpp": ["wanted flag"],
        "asm": []
    },
    "external_libraries": ["Servo"]
}
```

```json
{
    "fqbn": "arduino:esp32:nano_nora",
    "compile_flags": {
        "c": [
            "-DARDUINO_CORE_BUILD"
        ],
        "cpp": [
            "-DARDUINO_CORE_BUILD"
        ],
        "asm": []
    },
    "external_libraries": [
        "LiquidCrystal_I2C",
        "Servo"
    ]
}
```

## compile and Linking

libarduino_core.a and libarduino_external.a are compiled by the compile flags form arduino platform.txt configuration and down-stream app configuration. compile/archive tool is from arduino platform.txt.

- in arduino platform.txt, this crate will get recipe.c.o.pattern/recipe.cpp.o.pattern/recipe.S.o.pattern and split them to get the compile flags.

- in down-stream app configuration, this crate will get "compile_flags".

**Note:** before compile, this crate build.rs will remove "-lto" flag, if input flags(from arduino platform.txt or down-stream configuration)  contains it. because it will arise problem  that down-stream app can not link this crate as a rlib.

scope comment:
- libarduino_core.a scope:  {build.core.path}, {build.variant.path}, and "\<target-fqbn-platform-path>/libraries".

- libarduino_external.a scope: listed libraies in "\<arduino-user>/libraries"

binding comment:

- only generate binding for libarduino_external.a. 
- if you want to use some api in libarduino_core.a, you can manual provide the binding.

# down-stream app demo

Let's create a empty app. for example, through `cargo generate --git https://github.com/Rahix/avr-hal-template.git` ,specify the project name and select the board type, then you will get a rust down-stream app.  

Let's update app's Cargo.toml: add arduino-sys dependency

Let's update app's .cargo/config.toml: add ARDUINO_SYS env, and create the related custom.json file.

let's update main.rs. e.g.

```rust
#![no_std]
#![no_main]
extern crate arduino_sys;
use panic_halt as _;
use arduino_sys::{servo,liquidcrystal_i2c};
//  it is Arduino framework provided function to initialize the board. 
// We would need to call it in rust as well before we start using any Arduino library    
extern "C" {
    fn init();
}
#[arduino_hal::entry]
fn main() -> ! {
    unsafe{
    init();
    let mut s=servo::Servo::new();

    }
    let dp = arduino_hal::Peripherals::take().unwrap();
    let pins = arduino_hal::pins!(dp);

```

let's build the app.
